from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel, EmailStr
from datetime import datetime
import os
import uuid

from docx import Document
from pptx import Presentation
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from sqlalchemy.orm import Session
from database import get_db_connection
from auth import hash_password, verify_password, create_access_token



app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
REPORT_DIR = os.path.join(BASE_DIR, "reports")
os.makedirs(REPORT_DIR, exist_ok=True)

# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()

# -----------------------------
# REQUEST MODEL
# -----------------------------
class ReportRequest(BaseModel):
    companyName: str
    reportType: str
    insights: list[str]


class LoginRequest(BaseModel):
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    id: int
    name: str
    email: EmailStr

class TokenResponse(BaseModel):
    access_token: str
    token_type: str
    user: UserResponse


# -----------------------------
# PDF GENERATOR (SAFE)
# -----------------------------
def generate_pdf(data: ReportRequest, filepath: str):
    c = canvas.Canvas(filepath, pagesize=A4)
    width, height = A4

    # COVER PAGE
    c.setFont("Helvetica-Bold", 20)
    c.drawCentredString(width / 2, height - 120, data.companyName)

    c.setFont("Helvetica", 16)
    c.drawCentredString(
        width / 2, height - 160, f"{data.reportType} Energy Report"
    )

    c.setFont("Helvetica", 12)
    c.drawCentredString(
        width / 2, height - 200,
        f"Generated on {datetime.now().strftime('%d %b %Y')}"
    )

    c.drawCentredString(width / 2, 40, "Generated by InsightFlow")
    c.showPage()

    # CONTENT PAGES (2 INSIGHTS PER PAGE)
    for i in range(0, len(data.insights), 2):
        y = height - 80

        for j in range(2):
            if i + j >= len(data.insights):
                break

            # Graph placeholder
            c.rect(60, y - 100, width - 120, 60)
            c.drawString(70, y - 120, "Graph Placeholder")

            # Insight
            text = c.beginText(70, y - 150)
            text.setFont("Helvetica", 11)
            text.textLines(data.insights[i + j])
            c.drawText(text)

            y -= 240

        c.drawCentredString(width / 2, 40, "Generated by InsightFlow")
        c.showPage()

    c.save()


# -----------------------------
# WORD GENERATOR (SAFE)
# -----------------------------
def generate_word(data: ReportRequest, path: str):
    doc = Document()

    doc.add_heading(data.companyName, level=1)
    doc.add_heading(f"{data.reportType} Energy Report", level=2)
    doc.add_paragraph(f"Generated on: {datetime.now().strftime('%d %b %Y')}")
    doc.add_page_break()

    for i, insight in enumerate(data.insights):
        doc.add_paragraph("Graph Placeholder", style="Intense Quote")
        doc.add_paragraph(insight)

        if (i + 1) % 2 == 0:
            doc.add_page_break()

    doc.add_paragraph("Generated by InsightFlow")

    doc.save(path)



# -----------------------------
# PPT GENERATOR (SAFE)
# -----------------------------
def generate_ppt(data: ReportRequest, path: str):
    prs = Presentation()

    cover = prs.slides.add_slide(prs.slide_layouts[1])
    cover.shapes.title.text = data.companyName
    cover.placeholders[1].text = (
        f"{data.reportType} Energy Report\n"
        f"Generated on {datetime.now().strftime('%d %b %Y')}"
    )

    for insight in data.insights:
        slide = prs.slides.add_slide(prs.slide_layouts[1])
        slide.shapes.title.text = "Energy Insight"
        slide.placeholders[1].text = f"Graph Placeholder\n\n{insight}"

    prs.save(path)



# -----------------------------
# DOWNLOAD ENDPOINT
# -----------------------------
@app.post("/download-report/{format}")
def download_report(format: str, data: ReportRequest):

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_name = data.companyName.replace(" ", "_")

    if format == "pdf":
        filename = f"{safe_name}_{data.reportType}_{timestamp}.pdf"
        filepath = os.path.join(REPORT_DIR, filename)
        generate_pdf(data, filepath)
        media_type = "application/pdf"

    elif format == "docx":
        filename = f"{safe_name}_{data.reportType}_{timestamp}.docx"
        filepath = os.path.join(REPORT_DIR, filename)
        generate_word(data, filepath)
        media_type = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"

    elif format == "pptx":
        filename = f"{safe_name}_{data.reportType}_{timestamp}.pptx"
        filepath = os.path.join(REPORT_DIR, filename)
        generate_ppt(data, filepath)
        media_type = "application/vnd.openxmlformats-officedocument.presentationml.presentation"

    else:
        return {"error": "Unsupported format"}

    return FileResponse(
        path=filepath,
        filename=filename,
        media_type=media_type,
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )


class SignupRequest(BaseModel):
    name: str
    email: str
    password: str
    

@app.post("/auth/signup", response_model=TokenResponse)
def signup(data: SignupRequest):

    conn = get_db_connection()
    cur = conn.cursor()
    name_parts = data.name.strip().split(" ", 1)
    first_name = name_parts[0]
    last_name = name_parts[1] if len(name_parts) > 1 else ""
    email = data.email
    password = hash_password(data.password)
    try:
        cur.execute(
            """
            INSERT INTO public.users (first_name, last_name, email, password)
            VALUES (%s, %s, %s, %s)
            RETURNING id, first_name, last_name, email
            """,
            (first_name, last_name, email, password)
        )

        user = cur.fetchone()
        conn.commit()

        if not user:
            raise HTTPException(status_code=500, detail="User creation failed")

        # âœ… JWT TOKEN
        token = create_access_token({
            "sub": str(user[0]),
            "email": user[3]
        })

        return {
            "access_token": token,
            "token_type": "bearer",
            "user": {
                "id": user[0],
                "name": f"{user[1]} {user[2]}".strip(),
                "email": user[3]
            }
        }
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))

    finally:
        cur.close()
        conn.close()


@app.post("/auth/login", response_model=TokenResponse)
def login(data: LoginRequest):
    conn = get_db_connection()
    cur = conn.cursor()

    try:
        # Fetch user by email
        cur.execute(
            """
            SELECT id, first_name, last_name, email, password
            FROM public.users
            WHERE email = %s
            """,
            (data.email,)
        )

        user = cur.fetchone()

        if not user:
            raise HTTPException(status_code=401, detail="Invalid email or password")

        user_id, first_name, last_name, email, hashed_password = user

        # Verify password
        if not verify_password(data.password, hashed_password):
            raise HTTPException(status_code=401, detail="Invalid email or password")

        # Create JWT token
        token = create_access_token({
            "sub": str(user_id),
            "email": email
        })

        return {
            "access_token": token,
            "token_type": "bearer",
            "user": {
                "id": user_id,
                "name": f"{first_name} {last_name}".strip(),
                "email": email
            }
        }

    finally:
        cur.close()
        conn.close()