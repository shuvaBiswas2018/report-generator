from fastapi import FastAPI, Depends, HTTPException, status, APIRouter, Request
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.sessions import SessionMiddleware
from fastapi.responses import FileResponse, RedirectResponse
from pydantic import BaseModel, EmailStr
from datetime import datetime


import os
import uuid

from docx import Document
from pptx import Presentation
from reportlab.lib.pagesizes import A4
from reportlab.pdfgen import canvas
from sqlalchemy.orm import Session
from database import get_db_connection
from auth import hash_password, verify_password, create_access_token
from serp_agent import search_feature
from password_token_generator import generate_reset_token, reset_token_expiry
from email_utils import send_reset_email
from auth_utils import get_current_user




app = FastAPI()



app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


# Session middleware (REQUIRED for Google OAuth)
app.add_middleware(
    SessionMiddleware,
    secret_key="SUPER_SECRET_RANDOM_STRING",
    same_site="lax"
)


BASE_DIR = os.path.dirname(os.path.abspath(__file__))
REPORT_DIR = os.path.join(BASE_DIR, "reports")
os.makedirs(REPORT_DIR, exist_ok=True)

# def get_db():
#     db = SessionLocal()
#     try:
#         yield db
#     finally:
#         db.close()

# -----------------------------
# REQUEST MODEL
# -----------------------------
class ReportRequest(BaseModel):
    companyName: str
    reportType: str
    insights: list[str]


class LoginRequest(BaseModel):
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    id: int
    name: str
    email: EmailStr

class TokenResponse(BaseModel):
    access_token: str
    token_type: str
    user: UserResponse


class FeatureExplainRequest(BaseModel):
    feature: str


class SignupRequest(BaseModel):
    name: str
    email: str
    password: str

# -----------------------------
# PDF GENERATOR (SAFE)
# -----------------------------
def generate_pdf(data: ReportRequest, filepath: str):
    c = canvas.Canvas(filepath, pagesize=A4)
    width, height = A4

    # COVER PAGE
    c.setFont("Helvetica-Bold", 20)
    c.drawCentredString(width / 2, height - 120, data.companyName)

    c.setFont("Helvetica", 16)
    c.drawCentredString(
        width / 2, height - 160, f"{data.reportType} Energy Report"
    )

    c.setFont("Helvetica", 12)
    c.drawCentredString(
        width / 2, height - 200,
        f"Generated on {datetime.now().strftime('%d %b %Y')}"
    )

    c.drawCentredString(width / 2, 40, "Generated by InsightFlow")
    c.showPage()

    # CONTENT PAGES (2 INSIGHTS PER PAGE)
    for i in range(0, len(data.insights), 2):
        y = height - 80

        for j in range(2):
            if i + j >= len(data.insights):
                break

            # Graph placeholder
            c.rect(60, y - 100, width - 120, 60)
            c.drawString(70, y - 120, "Graph Placeholder")

            # Insight
            text = c.beginText(70, y - 150)
            text.setFont("Helvetica", 11)
            text.textLines(data.insights[i + j])
            c.drawText(text)

            y -= 240

        c.drawCentredString(width / 2, 40, "Generated by InsightFlow")
        c.showPage()

    c.save()


# -----------------------------
# WORD GENERATOR (SAFE)
# -----------------------------
def generate_word(data: ReportRequest, path: str):
    doc = Document()

    doc.add_heading(data.companyName, level=1)
    doc.add_heading(f"{data.reportType} Energy Report", level=2)
    doc.add_paragraph(f"Generated on: {datetime.now().strftime('%d %b %Y')}")
    doc.add_page_break()

    for i, insight in enumerate(data.insights):
        doc.add_paragraph("Graph Placeholder", style="Intense Quote")
        doc.add_paragraph(insight)

        if (i + 1) % 2 == 0:
            doc.add_page_break()

    doc.add_paragraph("Generated by InsightFlow")

    doc.save(path)



# -----------------------------
# PPT GENERATOR (SAFE)
# -----------------------------
def generate_ppt(data: ReportRequest, path: str):
    prs = Presentation()

    cover = prs.slides.add_slide(prs.slide_layouts[1])
    cover.shapes.title.text = data.companyName
    cover.placeholders[1].text = (
        f"{data.reportType} Energy Report\n"
        f"Generated on {datetime.now().strftime('%d %b %Y')}"
    )

    for insight in data.insights:
        slide = prs.slides.add_slide(prs.slide_layouts[1])
        slide.shapes.title.text = "Energy Insight"
        slide.placeholders[1].text = f"Graph Placeholder\n\n{insight}"

    prs.save(path)



# -----------------------------
# DOWNLOAD ENDPOINT
# -----------------------------
@app.post("/download-report/{format}")
def download_report(format: str, data: ReportRequest):

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_name = data.companyName.replace(" ", "_")

    if format == "pdf":
        filename = f"{safe_name}_{data.reportType}_{timestamp}.pdf"
        filepath = os.path.join(REPORT_DIR, filename)
        generate_pdf(data, filepath)
        media_type = "application/pdf"

    elif format == "docx":
        filename = f"{safe_name}_{data.reportType}_{timestamp}.docx"
        filepath = os.path.join(REPORT_DIR, filename)
        generate_word(data, filepath)
        media_type = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"

    elif format == "pptx":
        filename = f"{safe_name}_{data.reportType}_{timestamp}.pptx"
        filepath = os.path.join(REPORT_DIR, filename)
        generate_ppt(data, filepath)
        media_type = "application/vnd.openxmlformats-officedocument.presentationml.presentation"

    else:
        return {"error": "Unsupported format"}

    return FileResponse(
        path=filepath,
        filename=filename,
        media_type=media_type,
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )
    

@app.post("/auth/signup", response_model=TokenResponse)
def signup(data: SignupRequest):

    conn = get_db_connection()
    cur = conn.cursor()
    name_parts = data.name.strip().split(" ", 1)
    first_name = name_parts[0]
    last_name = name_parts[1] if len(name_parts) > 1 else ""
    email = data.email
    password = hash_password(data.password)
    try:
        cur.execute(
            """
            INSERT INTO public.users (first_name, last_name, email, password)
            VALUES (%s, %s, %s, %s)
            RETURNING id, first_name, last_name, email
            """,
            (first_name, last_name, email, password)
        )

        user = cur.fetchone()
        conn.commit()

        if not user:
            raise HTTPException(status_code=500, detail="User creation failed")

        # ‚úÖ JWT TOKEN
        token = create_access_token({
            "sub": str(user[0]),
            "email": user[3]
        })

        return {
            "access_token": token,
            "token_type": "bearer",
            "user": {
                "id": user[0],
                "name": f"{user[1]} {user[2]}".strip(),
                "email": user[3]
            }
        }
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))

    finally:
        cur.close()
        conn.close()


@app.post("/auth/login", response_model=TokenResponse)
def login(data: LoginRequest):
    conn = get_db_connection()
    cur = conn.cursor()

    try:
        # Fetch user by email
        cur.execute(
            """
            SELECT id, first_name, last_name, email, password
            FROM public.users
            WHERE email = %s
            """,
            (data.email,)
        )

        user = cur.fetchone()

        # ‚ùå Email NOT found
        if not user:
            raise HTTPException(
                status_code=401,
                detail="Invalid email and password"
            )
        
        user_id, first_name, last_name, email, hashed_password = user

        # 2Ô∏è‚É£ Email exists ‚Üí check password
        if not verify_password(data.password, hashed_password):
            raise HTTPException(
                status_code=401,
                detail="Invalid password"
            )
        # Create JWT token
        token = create_access_token({
            "sub": str(user_id),
            "email": email
        })

        return {
            "access_token": token,
            "token_type": "bearer",
            "user": {
                "id": user_id,
                "name": f"{first_name} {last_name}".strip(),
                "email": email
            }
        }

    finally:
        cur.close()
        conn.close()



# from pydantic import BaseModel, EmailStr

class ForgotPasswordRequest(BaseModel):
    email: EmailStr


@app.post("/auth/forgot-password")
def forgot_password(data: ForgotPasswordRequest):
    print(f"Password reset requested for email: {data.email}")
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute(
            "SELECT id FROM public.users WHERE email = %s",
            (data.email,)
        )
        user = cur.fetchone()
        # Always return success (security)
        if not user:
            raise HTTPException(
                status_code=404,
                detail="Your email doesn't exist in our system. Please register."
            )

        token = generate_reset_token()
        expires = reset_token_expiry()
        cur.execute(
            """
            INSERT INTO public.password_reset_tokens
            (user_id, token_hash, expires_at, used)
            VALUES (%s, %s, %s, FALSE) RETURNING id
            """,
            (user[0], token, expires)
        )
        
        conn.commit()

        reset_link = f"http://localhost:3001/reset-password?token={token}"
        print(f"Reset link: {reset_link}")
        send_reset_email(data.email, reset_link)

        return {"message": "A password reset link has been sent to this email."}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()


class ResetPasswordRequest(BaseModel):
    token: str
    password: str



@app.post("/auth/reset-password")
def reset_password(data: ResetPasswordRequest):
    print(f"Resetting password for token: {data.token}")
    conn = get_db_connection()
    cur = conn.cursor()
    try:
        cur.execute(
            """
            SELECT id, user_id, expires_at
            FROM password_reset_tokens
            WHERE token_hash = %s
            """,
            (data.token,)
        )

        row = cur.fetchone()

        if not row:
            raise HTTPException(status_code=400, detail="Invalid or expired token")

        id, user_id, expires_at = row

        print(f"user_id: {user_id}, expires_at: {expires_at}, now: {datetime.utcnow()}")

        if expires_at < datetime.utcnow():
            raise HTTPException(status_code=400, detail="Reset token expired")
        
        hashed = hash_password(data.password)

        cur.execute(
            """
            UPDATE public.password_reset_tokens
            SET used = TRUE
            WHERE id = %s
            """,
            (id,)
        )
        conn.commit()

        cur.execute(
            """
            UPDATE public.users
            SET password = %s
            WHERE id = %s
            """,
            (hashed, user_id)
        )
        conn.commit()
        return {"message": "Password reset successfully"}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()



class ChangePasswordRequest(BaseModel):
    user_id: int
    current_password: str
    new_password: str


@app.post("/auth/change-password")
def change_password(data: ChangePasswordRequest):

    conn = get_db_connection()
    cur = conn.cursor()

    try:
        # 1Ô∏è‚É£ Fetch existing password
        cur.execute(
            "SELECT password FROM users WHERE id = %s",
            (data.user_id,)
        )
        row = cur.fetchone()

        if not row:
            raise HTTPException(status_code=404, detail="User not found")

        stored_password = row[0]

        # 2Ô∏è‚É£ Verify current password
        if not verify_password(data.current_password, stored_password):
            raise HTTPException(
                status_code=400,
                detail="Current password is incorrect"
            )

        # 3Ô∏è‚É£ Prevent same password reuse
        if verify_password(data.new_password, stored_password):
            raise HTTPException(
                status_code=400,
                detail="New password must be different from current password"
            )

        # 4Ô∏è‚É£ Update password
        new_hashed = hash_password(data.new_password)

        cur.execute(
            """
            UPDATE users
            SET password = %s
            WHERE id = %s
            """,
            (new_hashed, data.user_id)
        )

        conn.commit()

        return {
            "message": "Password updated successfully"
        }

    except HTTPException:
        conn.rollback()
        raise
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        cur.close()
        conn.close()


@app.post("/api/contact")
def contact_endpoint(request: dict):
    # Here you would normally process the contact request,
    # e.g., save it to the database or send an email.
    #Save it to database
    conn = get_db_connection()
    cur = conn.cursor()
    user_id = request.get("user_id")
    if user_id is None:
        cur.execute(
                "SELECT id FROM public.users WHERE email = %s",
                (request.get("email"),)
        )
        existing_user = cur.fetchone()

        if existing_user:
            user_id = existing_user[0]
        else:
            cur.execute("""INSERT INTO public.users (first_name, last_name, email, password)
                        VALUES (%s, %s, %s, %s)
                        RETURNING id""",
                        (request.get("name").split(" ")[0],
                        " ".join(request.get("name").split(" ")[1:]) if len(request.get("name").split(" ")) > 1 else "",
                        request.get("email"),
                        ""))
            user_id = cur.fetchone()[0]
        conn.commit()
    try:
        cur.execute(
            """
            INSERT INTO public.contact_requests (user_id, message, request_type_id, created_at)
            VALUES (%s, %s, %s, %s)
            """,
            (
                user_id,
                request.get("message"),
                request.get("infoType"),
                datetime.utcnow()
            )
        )
        conn.commit()
        return {"status_code": 200, "detail": "Contact request submitted successfully."}
    except Exception as e:
        conn.rollback()
        raise HTTPException(status_code=400, detail=str(e))
    finally:
        cur.close()
        conn.close()


@app.post("/ai/feature-explain")
def explain_feature(req: FeatureExplainRequest):
    if not req.feature:
        raise HTTPException(status_code=400, detail="Feature is required")

    print(f"Explaining feature: {req.feature}")
    results = search_feature(req.feature)

    print(f"Search results: {results}")
    return {
        "feature": req.feature,
        "overview": f"AI-curated insights about {req.feature}",
        "sources": results
    }

from auth_google import oauth

@app.get("/auth/google/login")
async def google_login(request: Request):
    redirect_uri = "http://localhost:8000/auth/google/callback"
    return await oauth.google.authorize_redirect(request, redirect_uri)


@app.get("/auth/google/callback")
async def google_callback(request: Request):
    token = await oauth.google.authorize_access_token(request)
    user_info = token.get("userinfo")

    email = user_info["email"]
    name = user_info["name"]

    conn = get_db_connection()
    cur = conn.cursor()

    # Check if user exists
    cur.execute("SELECT id, first_name, last_name, email FROM users WHERE email = %s", (email,))
    user = cur.fetchone()

    if not user:
        first_name = name.split(" ")[0]
        last_name = " ".join(name.split(" ")[1:]) if len(name.split(" ")) > 1 else ""

        cur.execute(
            """
            INSERT INTO users (first_name, last_name, email, password, auth_provider)
            VALUES (%s, %s, %s, %s, %s)
            RETURNING id
            """,
            (first_name, last_name, email, "", "google")
        )
        user_id = cur.fetchone()[0]
        conn.commit()
    else:
        user_id = user[0]

    cur.close()
    conn.close()

    jwt_token = create_access_token({
        "sub": str(user_id),
        "email": email
    })
    
    # Redirect back to frontend
    return RedirectResponse(
        url=f"http://localhost:3001/oauth-success?token={jwt_token}"
    )


@app.get("/auth/me")
def get_me(user=Depends(get_current_user)):
    print(f"Current user: {user}")
    user_id, name, email = user
    return user


# @app.get("/auth/google/callback")
# async def google_callback(request: Request):
#     token = await oauth.google.authorize_access_token(request)

#     user_info = token.get("userinfo")
#     if not user_info:
#         raise HTTPException(status_code=400, detail="Google login failed")

#     email = user_info["email"]
#     name = user_info["name"]

#     # üîπ create / fetch user from DB here

#     jwt_token = create_access_token({
#         "sub": email,
#         "name": name
#     })

#     return {
#         "access_token": jwt_token,
#         "token_type": "bearer",
#         "user": {
#             "email": email,
#             "name": name
#         }
#     }